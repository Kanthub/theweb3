// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: protobuf/wallet.proto

package wallet

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ReturnCode int32

const (
	ReturnCode_ERROR   ReturnCode = 0
	ReturnCode_SUCCESS ReturnCode = 1
)

// Enum value maps for ReturnCode.
var (
	ReturnCode_name = map[int32]string{
		0: "ERROR",
		1: "SUCCESS",
	}
	ReturnCode_value = map[string]int32{
		"ERROR":   0,
		"SUCCESS": 1,
	}
)

func (x ReturnCode) Enum() *ReturnCode {
	p := new(ReturnCode)
	*p = x
	return p
}

func (x ReturnCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReturnCode) Descriptor() protoreflect.EnumDescriptor {
	return file_protobuf_wallet_proto_enumTypes[0].Descriptor()
}

func (ReturnCode) Type() protoreflect.EnumType {
	return &file_protobuf_wallet_proto_enumTypes[0]
}

func (x ReturnCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReturnCode.Descriptor instead.
func (ReturnCode) EnumDescriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{0}
}

type ChainSignMethodRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	AssetType     string                 `protobuf:"bytes,4,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChainSignMethodRequest) Reset() {
	*x = ChainSignMethodRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainSignMethodRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainSignMethodRequest) ProtoMessage() {}

func (x *ChainSignMethodRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainSignMethodRequest.ProtoReflect.Descriptor instead.
func (*ChainSignMethodRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{0}
}

func (x *ChainSignMethodRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *ChainSignMethodRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *ChainSignMethodRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *ChainSignMethodRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

type ChainSignMethodResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	SignMethod    string                 `protobuf:"bytes,3,opt,name=sign_method,json=signMethod,proto3" json:"sign_method,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChainSignMethodResponse) Reset() {
	*x = ChainSignMethodResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainSignMethodResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainSignMethodResponse) ProtoMessage() {}

func (x *ChainSignMethodResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainSignMethodResponse.ProtoReflect.Descriptor instead.
func (*ChainSignMethodResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{1}
}

func (x *ChainSignMethodResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *ChainSignMethodResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ChainSignMethodResponse) GetSignMethod() string {
	if x != nil {
		return x.SignMethod
	}
	return ""
}

type ChainSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	AssetType     string                 `protobuf:"bytes,4,opt,name=asset_type,json=assetType,proto3" json:"asset_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChainSchemaRequest) Reset() {
	*x = ChainSchemaRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainSchemaRequest) ProtoMessage() {}

func (x *ChainSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainSchemaRequest.ProtoReflect.Descriptor instead.
func (*ChainSchemaRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{2}
}

func (x *ChainSchemaRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *ChainSchemaRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *ChainSchemaRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *ChainSchemaRequest) GetAssetType() string {
	if x != nil {
		return x.AssetType
	}
	return ""
}

type ChainSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Schema        string                 `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChainSchemaResponse) Reset() {
	*x = ChainSchemaResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainSchemaResponse) ProtoMessage() {}

func (x *ChainSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainSchemaResponse.ProtoReflect.Descriptor instead.
func (*ChainSchemaResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{3}
}

func (x *ChainSchemaResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *ChainSchemaResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ChainSchemaResponse) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

type ExportPublicKey struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PublicKey         string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	CompressPublicKey string                 `protobuf:"bytes,2,opt,name=compress_public_key,json=compressPublicKey,proto3" json:"compress_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ExportPublicKey) Reset() {
	*x = ExportPublicKey{}
	mi := &file_protobuf_wallet_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportPublicKey) ProtoMessage() {}

func (x *ExportPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportPublicKey.ProtoReflect.Descriptor instead.
func (*ExportPublicKey) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{4}
}

func (x *ExportPublicKey) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ExportPublicKey) GetCompressPublicKey() string {
	if x != nil {
		return x.CompressPublicKey
	}
	return ""
}

type ExportPublicKeyWithAddresses struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PublicKey         string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	CompressPublicKey string                 `protobuf:"bytes,2,opt,name=compress_public_key,json=compressPublicKey,proto3" json:"compress_public_key,omitempty"`
	Address           string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ExportPublicKeyWithAddresses) Reset() {
	*x = ExportPublicKeyWithAddresses{}
	mi := &file_protobuf_wallet_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportPublicKeyWithAddresses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportPublicKeyWithAddresses) ProtoMessage() {}

func (x *ExportPublicKeyWithAddresses) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportPublicKeyWithAddresses.ProtoReflect.Descriptor instead.
func (*ExportPublicKeyWithAddresses) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{5}
}

func (x *ExportPublicKeyWithAddresses) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ExportPublicKeyWithAddresses) GetCompressPublicKey() string {
	if x != nil {
		return x.CompressPublicKey
	}
	return ""
}

func (x *ExportPublicKeyWithAddresses) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type CreateKeyPairAndExportPublicKeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	KeyNum        string                 `protobuf:"bytes,4,opt,name=key_num,json=keyNum,proto3" json:"key_num,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateKeyPairAndExportPublicKeyRequest) Reset() {
	*x = CreateKeyPairAndExportPublicKeyRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairAndExportPublicKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairAndExportPublicKeyRequest) ProtoMessage() {}

func (x *CreateKeyPairAndExportPublicKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairAndExportPublicKeyRequest.ProtoReflect.Descriptor instead.
func (*CreateKeyPairAndExportPublicKeyRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{6}
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyRequest) GetKeyNum() string {
	if x != nil {
		return x.KeyNum
	}
	return ""
}

type CreateKeyPairAndExportPublicKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PublicKeyList []*ExportPublicKey     `protobuf:"bytes,3,rep,name=public_key_list,json=publicKeyList,proto3" json:"public_key_list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateKeyPairAndExportPublicKeyResponse) Reset() {
	*x = CreateKeyPairAndExportPublicKeyResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateKeyPairAndExportPublicKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateKeyPairAndExportPublicKeyResponse) ProtoMessage() {}

func (x *CreateKeyPairAndExportPublicKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateKeyPairAndExportPublicKeyResponse.ProtoReflect.Descriptor instead.
func (*CreateKeyPairAndExportPublicKeyResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{7}
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *CreateKeyPairAndExportPublicKeyResponse) GetPublicKeyList() []*ExportPublicKey {
	if x != nil {
		return x.PublicKeyList
	}
	return nil
}

type BuildAndSignTransactionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	SignType      string                 `protobuf:"bytes,4,opt,name=sign_type,json=signType,proto3" json:"sign_type,omitempty"`
	PublicKey     string                 `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	TxMessageHash string                 `protobuf:"bytes,6,opt,name=tx_message_hash,json=txMessageHash,proto3" json:"tx_message_hash,omitempty"`
	WalletKeyHash string                 `protobuf:"bytes,7,opt,name=wallet_key_hash,json=walletKeyHash,proto3" json:"wallet_key_hash,omitempty"`
	RiskKeyHash   string                 `protobuf:"bytes,8,opt,name=risk_key_hash,json=riskKeyHash,proto3" json:"risk_key_hash,omitempty"`
	TxBase64Body  string                 `protobuf:"bytes,9,opt,name=tx_base64_body,json=txBase64Body,proto3" json:"tx_base64_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignTransactionRequest) Reset() {
	*x = BuildAndSignTransactionRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignTransactionRequest) ProtoMessage() {}

func (x *BuildAndSignTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignTransactionRequest.ProtoReflect.Descriptor instead.
func (*BuildAndSignTransactionRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{8}
}

func (x *BuildAndSignTransactionRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetSignType() string {
	if x != nil {
		return x.SignType
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetTxMessageHash() string {
	if x != nil {
		return x.TxMessageHash
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetWalletKeyHash() string {
	if x != nil {
		return x.WalletKeyHash
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetRiskKeyHash() string {
	if x != nil {
		return x.RiskKeyHash
	}
	return ""
}

func (x *BuildAndSignTransactionRequest) GetTxBase64Body() string {
	if x != nil {
		return x.TxBase64Body
	}
	return ""
}

type BuildAndSignTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	TxMessageHash string                 `protobuf:"bytes,3,opt,name=tx_message_hash,json=txMessageHash,proto3" json:"tx_message_hash,omitempty"`
	TxHash        string                 `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	SignedTx      string                 `protobuf:"bytes,5,opt,name=signed_tx,json=signedTx,proto3" json:"signed_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignTransactionResponse) Reset() {
	*x = BuildAndSignTransactionResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignTransactionResponse) ProtoMessage() {}

func (x *BuildAndSignTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignTransactionResponse.ProtoReflect.Descriptor instead.
func (*BuildAndSignTransactionResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{9}
}

func (x *BuildAndSignTransactionResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *BuildAndSignTransactionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetTxMessageHash() string {
	if x != nil {
		return x.TxMessageHash
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *BuildAndSignTransactionResponse) GetSignedTx() string {
	if x != nil {
		return x.SignedTx
	}
	return ""
}

type TransactionMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PublicKey     string                 `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	SignType      string                 `protobuf:"bytes,2,opt,name=sign_type,json=signType,proto3" json:"sign_type,omitempty"`
	WalletKeyHash string                 `protobuf:"bytes,3,opt,name=wallet_key_hash,json=walletKeyHash,proto3" json:"wallet_key_hash,omitempty"`
	RiskKeyHash   string                 `protobuf:"bytes,4,opt,name=risk_key_hash,json=riskKeyHash,proto3" json:"risk_key_hash,omitempty"`
	TxBase64Body  string                 `protobuf:"bytes,5,opt,name=tx_base64_body,json=txBase64Body,proto3" json:"tx_base64_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionMessage) Reset() {
	*x = TransactionMessage{}
	mi := &file_protobuf_wallet_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionMessage) ProtoMessage() {}

func (x *TransactionMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionMessage.ProtoReflect.Descriptor instead.
func (*TransactionMessage) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{10}
}

func (x *TransactionMessage) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *TransactionMessage) GetSignType() string {
	if x != nil {
		return x.SignType
	}
	return ""
}

func (x *TransactionMessage) GetWalletKeyHash() string {
	if x != nil {
		return x.WalletKeyHash
	}
	return ""
}

func (x *TransactionMessage) GetRiskKeyHash() string {
	if x != nil {
		return x.RiskKeyHash
	}
	return ""
}

func (x *TransactionMessage) GetTxBase64Body() string {
	if x != nil {
		return x.TxBase64Body
	}
	return ""
}

type TransactionWithSign struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TxMessageHash string                 `protobuf:"bytes,1,opt,name=tx_message_hash,json=txMessageHash,proto3" json:"tx_message_hash,omitempty"`
	TxHash        string                 `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	SignedTx      string                 `protobuf:"bytes,3,opt,name=signed_tx,json=signedTx,proto3" json:"signed_tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionWithSign) Reset() {
	*x = TransactionWithSign{}
	mi := &file_protobuf_wallet_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionWithSign) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionWithSign) ProtoMessage() {}

func (x *TransactionWithSign) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionWithSign.ProtoReflect.Descriptor instead.
func (*TransactionWithSign) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{11}
}

func (x *TransactionWithSign) GetTxMessageHash() string {
	if x != nil {
		return x.TxMessageHash
	}
	return ""
}

func (x *TransactionWithSign) GetTxHash() string {
	if x != nil {
		return x.TxHash
	}
	return ""
}

func (x *TransactionWithSign) GetSignedTx() string {
	if x != nil {
		return x.SignedTx
	}
	return ""
}

type BuildAndSignBatchTransactionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	TxMsg         []*TransactionMessage  `protobuf:"bytes,4,rep,name=tx_msg,json=txMsg,proto3" json:"tx_msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignBatchTransactionRequest) Reset() {
	*x = BuildAndSignBatchTransactionRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignBatchTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignBatchTransactionRequest) ProtoMessage() {}

func (x *BuildAndSignBatchTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignBatchTransactionRequest.ProtoReflect.Descriptor instead.
func (*BuildAndSignBatchTransactionRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{12}
}

func (x *BuildAndSignBatchTransactionRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *BuildAndSignBatchTransactionRequest) GetTxMsg() []*TransactionMessage {
	if x != nil {
		return x.TxMsg
	}
	return nil
}

type BuildAndSignBatchTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ReturnCode             `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	TxWithSign    []*TransactionWithSign `protobuf:"bytes,3,rep,name=tx_with_sign,json=txWithSign,proto3" json:"tx_with_sign,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildAndSignBatchTransactionResponse) Reset() {
	*x = BuildAndSignBatchTransactionResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildAndSignBatchTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildAndSignBatchTransactionResponse) ProtoMessage() {}

func (x *BuildAndSignBatchTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildAndSignBatchTransactionResponse.ProtoReflect.Descriptor instead.
func (*BuildAndSignBatchTransactionResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{13}
}

func (x *BuildAndSignBatchTransactionResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *BuildAndSignBatchTransactionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BuildAndSignBatchTransactionResponse) GetTxWithSign() []*TransactionWithSign {
	if x != nil {
		return x.TxWithSign
	}
	return nil
}

type CreatKeyPairsWithAddressesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConsumerToken string                 `protobuf:"bytes,1,opt,name=consumer_token,json=consumerToken,proto3" json:"consumer_token,omitempty"`
	ChainName     string                 `protobuf:"bytes,2,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Network       string                 `protobuf:"bytes,3,opt,name=network,proto3" json:"network,omitempty"`
	KeyNum        string                 `protobuf:"bytes,4,opt,name=key_num,json=keyNum,proto3" json:"key_num,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreatKeyPairsWithAddressesRequest) Reset() {
	*x = CreatKeyPairsWithAddressesRequest{}
	mi := &file_protobuf_wallet_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreatKeyPairsWithAddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreatKeyPairsWithAddressesRequest) ProtoMessage() {}

func (x *CreatKeyPairsWithAddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreatKeyPairsWithAddressesRequest.ProtoReflect.Descriptor instead.
func (*CreatKeyPairsWithAddressesRequest) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{14}
}

func (x *CreatKeyPairsWithAddressesRequest) GetConsumerToken() string {
	if x != nil {
		return x.ConsumerToken
	}
	return ""
}

func (x *CreatKeyPairsWithAddressesRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *CreatKeyPairsWithAddressesRequest) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *CreatKeyPairsWithAddressesRequest) GetKeyNum() string {
	if x != nil {
		return x.KeyNum
	}
	return ""
}

type CreatKeyPairsWithAddressesResponse struct {
	state              protoimpl.MessageState          `protogen:"open.v1"`
	Code               ReturnCode                      `protobuf:"varint,1,opt,name=code,proto3,enum=kanthub.wallet.ReturnCode" json:"code,omitempty"`
	Message            string                          `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PublicKeyAddresses []*ExportPublicKeyWithAddresses `protobuf:"bytes,3,rep,name=public_key_addresses,json=publicKeyAddresses,proto3" json:"public_key_addresses,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CreatKeyPairsWithAddressesResponse) Reset() {
	*x = CreatKeyPairsWithAddressesResponse{}
	mi := &file_protobuf_wallet_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreatKeyPairsWithAddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreatKeyPairsWithAddressesResponse) ProtoMessage() {}

func (x *CreatKeyPairsWithAddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protobuf_wallet_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreatKeyPairsWithAddressesResponse.ProtoReflect.Descriptor instead.
func (*CreatKeyPairsWithAddressesResponse) Descriptor() ([]byte, []int) {
	return file_protobuf_wallet_proto_rawDescGZIP(), []int{15}
}

func (x *CreatKeyPairsWithAddressesResponse) GetCode() ReturnCode {
	if x != nil {
		return x.Code
	}
	return ReturnCode_ERROR
}

func (x *CreatKeyPairsWithAddressesResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *CreatKeyPairsWithAddressesResponse) GetPublicKeyAddresses() []*ExportPublicKeyWithAddresses {
	if x != nil {
		return x.PublicKeyAddresses
	}
	return nil
}

var File_protobuf_wallet_proto protoreflect.FileDescriptor

const file_protobuf_wallet_proto_rawDesc = "" +
	"\n" +
	"\x15protobuf/wallet.proto\x12\x0ekanthub.wallet\"\x97\x01\n" +
	"\x16ChainSignMethodRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x04 \x01(\tR\tassetType\"\x84\x01\n" +
	"\x17ChainSignMethodResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1f\n" +
	"\vsign_method\x18\x03 \x01(\tR\n" +
	"signMethod\"\x93\x01\n" +
	"\x12ChainSchemaRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1d\n" +
	"\n" +
	"asset_type\x18\x04 \x01(\tR\tassetType\"w\n" +
	"\x13ChainSchemaResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x16\n" +
	"\x06schema\x18\x03 \x01(\tR\x06schema\"`\n" +
	"\x0fExportPublicKey\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12.\n" +
	"\x13compress_public_key\x18\x02 \x01(\tR\x11compressPublicKey\"\x87\x01\n" +
	"\x1cExportPublicKeyWithAddresses\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12.\n" +
	"\x13compress_public_key\x18\x02 \x01(\tR\x11compressPublicKey\x12\x18\n" +
	"\aaddress\x18\x03 \x01(\tR\aaddress\"\xa1\x01\n" +
	"&CreateKeyPairAndExportPublicKeyRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x17\n" +
	"\akey_num\x18\x04 \x01(\tR\x06keyNum\"\xbc\x01\n" +
	"'CreateKeyPairAndExportPublicKeyResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12G\n" +
	"\x0fpublic_key_list\x18\x03 \x03(\v2\x1f.kanthub.wallet.ExportPublicKeyR\rpublicKeyList\"\xd6\x02\n" +
	"\x1eBuildAndSignTransactionRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x1b\n" +
	"\tsign_type\x18\x04 \x01(\tR\bsignType\x12\x1d\n" +
	"\n" +
	"public_key\x18\x05 \x01(\tR\tpublicKey\x12&\n" +
	"\x0ftx_message_hash\x18\x06 \x01(\tR\rtxMessageHash\x12&\n" +
	"\x0fwallet_key_hash\x18\a \x01(\tR\rwalletKeyHash\x12\"\n" +
	"\rrisk_key_hash\x18\b \x01(\tR\vriskKeyHash\x12$\n" +
	"\x0etx_base64_body\x18\t \x01(\tR\ftxBase64Body\"\xc9\x01\n" +
	"\x1fBuildAndSignTransactionResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12&\n" +
	"\x0ftx_message_hash\x18\x03 \x01(\tR\rtxMessageHash\x12\x17\n" +
	"\atx_hash\x18\x04 \x01(\tR\x06txHash\x12\x1b\n" +
	"\tsigned_tx\x18\x05 \x01(\tR\bsignedTx\"\xc2\x01\n" +
	"\x12TransactionMessage\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\tR\tpublicKey\x12\x1b\n" +
	"\tsign_type\x18\x02 \x01(\tR\bsignType\x12&\n" +
	"\x0fwallet_key_hash\x18\x03 \x01(\tR\rwalletKeyHash\x12\"\n" +
	"\rrisk_key_hash\x18\x04 \x01(\tR\vriskKeyHash\x12$\n" +
	"\x0etx_base64_body\x18\x05 \x01(\tR\ftxBase64Body\"s\n" +
	"\x13TransactionWithSign\x12&\n" +
	"\x0ftx_message_hash\x18\x01 \x01(\tR\rtxMessageHash\x12\x17\n" +
	"\atx_hash\x18\x02 \x01(\tR\x06txHash\x12\x1b\n" +
	"\tsigned_tx\x18\x03 \x01(\tR\bsignedTx\"\xc0\x01\n" +
	"#BuildAndSignBatchTransactionRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x129\n" +
	"\x06tx_msg\x18\x04 \x03(\v2\".kanthub.wallet.TransactionMessageR\x05txMsg\"\xb7\x01\n" +
	"$BuildAndSignBatchTransactionResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12E\n" +
	"\ftx_with_sign\x18\x03 \x03(\v2#.kanthub.wallet.TransactionWithSignR\n" +
	"txWithSign\"\x9c\x01\n" +
	"!CreatKeyPairsWithAddressesRequest\x12%\n" +
	"\x0econsumer_token\x18\x01 \x01(\tR\rconsumerToken\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x02 \x01(\tR\tchainName\x12\x18\n" +
	"\anetwork\x18\x03 \x01(\tR\anetwork\x12\x17\n" +
	"\akey_num\x18\x04 \x01(\tR\x06keyNum\"\xce\x01\n" +
	"\"CreatKeyPairsWithAddressesResponse\x12.\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1a.kanthub.wallet.ReturnCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12^\n" +
	"\x14public_key_addresses\x18\x03 \x03(\v2,.kanthub.wallet.ExportPublicKeyWithAddressesR\x12publicKeyAddresses*$\n" +
	"\n" +
	"ReturnCode\x12\t\n" +
	"\x05ERROR\x10\x00\x12\v\n" +
	"\aSUCCESS\x10\x012\xfc\x05\n" +
	"\rWalletService\x12c\n" +
	"\x0egetChainMethod\x12&.kanthub.wallet.ChainSignMethodRequest\x1a'.kanthub.wallet.ChainSignMethodResponse\"\x00\x12[\n" +
	"\x0egetChainSchema\x12\".kanthub.wallet.ChainSchemaRequest\x1a#.kanthub.wallet.ChainSchemaResponse\"\x00\x12\x99\x01\n" +
	"$createKeyPairsAndExportPublicKeyList\x126.kanthub.wallet.CreateKeyPairAndExportPublicKeyRequest\x1a7.kanthub.wallet.CreateKeyPairAndExportPublicKeyResponse\"\x00\x12\x85\x01\n" +
	"\x1acreatKeyPairsWithAddresses\x121.kanthub.wallet.CreatKeyPairsWithAddressesRequest\x1a2.kanthub.wallet.CreatKeyPairsWithAddressesResponse\"\x00\x12|\n" +
	"\x17buildAndSignTransaction\x12..kanthub.wallet.BuildAndSignTransactionRequest\x1a/.kanthub.wallet.BuildAndSignTransactionResponse\"\x00\x12\x86\x01\n" +
	"\x1cbuildAndSignBatchTransaction\x123.kanthub.wallet.BuildAndSignBatchTransactionRequest\x1a/.kanthub.wallet.BuildAndSignTransactionResponse\"\x00B\x13Z\x11./protobuf/walletb\x06proto3"

var (
	file_protobuf_wallet_proto_rawDescOnce sync.Once
	file_protobuf_wallet_proto_rawDescData []byte
)

func file_protobuf_wallet_proto_rawDescGZIP() []byte {
	file_protobuf_wallet_proto_rawDescOnce.Do(func() {
		file_protobuf_wallet_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_protobuf_wallet_proto_rawDesc), len(file_protobuf_wallet_proto_rawDesc)))
	})
	return file_protobuf_wallet_proto_rawDescData
}

var file_protobuf_wallet_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_protobuf_wallet_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_protobuf_wallet_proto_goTypes = []any{
	(ReturnCode)(0),                                 // 0: kanthub.wallet.ReturnCode
	(*ChainSignMethodRequest)(nil),                  // 1: kanthub.wallet.ChainSignMethodRequest
	(*ChainSignMethodResponse)(nil),                 // 2: kanthub.wallet.ChainSignMethodResponse
	(*ChainSchemaRequest)(nil),                      // 3: kanthub.wallet.ChainSchemaRequest
	(*ChainSchemaResponse)(nil),                     // 4: kanthub.wallet.ChainSchemaResponse
	(*ExportPublicKey)(nil),                         // 5: kanthub.wallet.ExportPublicKey
	(*ExportPublicKeyWithAddresses)(nil),            // 6: kanthub.wallet.ExportPublicKeyWithAddresses
	(*CreateKeyPairAndExportPublicKeyRequest)(nil),  // 7: kanthub.wallet.CreateKeyPairAndExportPublicKeyRequest
	(*CreateKeyPairAndExportPublicKeyResponse)(nil), // 8: kanthub.wallet.CreateKeyPairAndExportPublicKeyResponse
	(*BuildAndSignTransactionRequest)(nil),          // 9: kanthub.wallet.BuildAndSignTransactionRequest
	(*BuildAndSignTransactionResponse)(nil),         // 10: kanthub.wallet.BuildAndSignTransactionResponse
	(*TransactionMessage)(nil),                      // 11: kanthub.wallet.TransactionMessage
	(*TransactionWithSign)(nil),                     // 12: kanthub.wallet.TransactionWithSign
	(*BuildAndSignBatchTransactionRequest)(nil),     // 13: kanthub.wallet.BuildAndSignBatchTransactionRequest
	(*BuildAndSignBatchTransactionResponse)(nil),    // 14: kanthub.wallet.BuildAndSignBatchTransactionResponse
	(*CreatKeyPairsWithAddressesRequest)(nil),       // 15: kanthub.wallet.CreatKeyPairsWithAddressesRequest
	(*CreatKeyPairsWithAddressesResponse)(nil),      // 16: kanthub.wallet.CreatKeyPairsWithAddressesResponse
}
var file_protobuf_wallet_proto_depIdxs = []int32{
	0,  // 0: kanthub.wallet.ChainSignMethodResponse.code:type_name -> kanthub.wallet.ReturnCode
	0,  // 1: kanthub.wallet.ChainSchemaResponse.code:type_name -> kanthub.wallet.ReturnCode
	0,  // 2: kanthub.wallet.CreateKeyPairAndExportPublicKeyResponse.code:type_name -> kanthub.wallet.ReturnCode
	5,  // 3: kanthub.wallet.CreateKeyPairAndExportPublicKeyResponse.public_key_list:type_name -> kanthub.wallet.ExportPublicKey
	0,  // 4: kanthub.wallet.BuildAndSignTransactionResponse.code:type_name -> kanthub.wallet.ReturnCode
	11, // 5: kanthub.wallet.BuildAndSignBatchTransactionRequest.tx_msg:type_name -> kanthub.wallet.TransactionMessage
	0,  // 6: kanthub.wallet.BuildAndSignBatchTransactionResponse.code:type_name -> kanthub.wallet.ReturnCode
	12, // 7: kanthub.wallet.BuildAndSignBatchTransactionResponse.tx_with_sign:type_name -> kanthub.wallet.TransactionWithSign
	0,  // 8: kanthub.wallet.CreatKeyPairsWithAddressesResponse.code:type_name -> kanthub.wallet.ReturnCode
	6,  // 9: kanthub.wallet.CreatKeyPairsWithAddressesResponse.public_key_addresses:type_name -> kanthub.wallet.ExportPublicKeyWithAddresses
	1,  // 10: kanthub.wallet.WalletService.getChainMethod:input_type -> kanthub.wallet.ChainSignMethodRequest
	3,  // 11: kanthub.wallet.WalletService.getChainSchema:input_type -> kanthub.wallet.ChainSchemaRequest
	7,  // 12: kanthub.wallet.WalletService.createKeyPairsAndExportPublicKeyList:input_type -> kanthub.wallet.CreateKeyPairAndExportPublicKeyRequest
	15, // 13: kanthub.wallet.WalletService.creatKeyPairsWithAddresses:input_type -> kanthub.wallet.CreatKeyPairsWithAddressesRequest
	9,  // 14: kanthub.wallet.WalletService.buildAndSignTransaction:input_type -> kanthub.wallet.BuildAndSignTransactionRequest
	13, // 15: kanthub.wallet.WalletService.buildAndSignBatchTransaction:input_type -> kanthub.wallet.BuildAndSignBatchTransactionRequest
	2,  // 16: kanthub.wallet.WalletService.getChainMethod:output_type -> kanthub.wallet.ChainSignMethodResponse
	4,  // 17: kanthub.wallet.WalletService.getChainSchema:output_type -> kanthub.wallet.ChainSchemaResponse
	8,  // 18: kanthub.wallet.WalletService.createKeyPairsAndExportPublicKeyList:output_type -> kanthub.wallet.CreateKeyPairAndExportPublicKeyResponse
	16, // 19: kanthub.wallet.WalletService.creatKeyPairsWithAddresses:output_type -> kanthub.wallet.CreatKeyPairsWithAddressesResponse
	10, // 20: kanthub.wallet.WalletService.buildAndSignTransaction:output_type -> kanthub.wallet.BuildAndSignTransactionResponse
	10, // 21: kanthub.wallet.WalletService.buildAndSignBatchTransaction:output_type -> kanthub.wallet.BuildAndSignTransactionResponse
	16, // [16:22] is the sub-list for method output_type
	10, // [10:16] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_protobuf_wallet_proto_init() }
func file_protobuf_wallet_proto_init() {
	if File_protobuf_wallet_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_protobuf_wallet_proto_rawDesc), len(file_protobuf_wallet_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_protobuf_wallet_proto_goTypes,
		DependencyIndexes: file_protobuf_wallet_proto_depIdxs,
		EnumInfos:         file_protobuf_wallet_proto_enumTypes,
		MessageInfos:      file_protobuf_wallet_proto_msgTypes,
	}.Build()
	File_protobuf_wallet_proto = out.File
	file_protobuf_wallet_proto_goTypes = nil
	file_protobuf_wallet_proto_depIdxs = nil
}
